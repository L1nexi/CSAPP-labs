## ICS lab2: B0mblab
### 李希文 22307130256
------
##### phase_1
进入 `phase_1`，注意到函数 `string_not_equal`， 且传递参数之一为 `"Computer science is not a boring subject"`，检验通过。

##### phase_2
首先进入 `phase_2` 的反汇编代码，注意到有个函数 `read_six_numbers`。观察传参情况，发现传了我们输入的字符串以及一个（反汇编器提示的）数组，跟入 `read_six_numbers` 看一看。

注意到前面似乎一直在传递参数，且每一个参数都是 `eax` 加上一定的偏移量，由此可以推断这是一个 `int` 数组（其实也可能是 `unsigned`,不过后面可以排除）。

![2_1](pic/2_1.png)

结合 `sscanf` 以及后面的几行代码可以知道，`read_six_numbers` 的条件是读取到六个整数，且第一个整数不为 `0`。由此，这个函数已经结束，回到 `phase_2`

接下来执行的代码首先储存了数组的首地址，然后还设置了一个奇怪的变量，当这个变量等于 5 时跳转。可以发现这里的跳转是正确出口，接下来考虑如何让这个变量等于 5。

再次查看代码，发现在一个 `cmp` 语句后出现了条件跳转，其中一个分支可以让这个变量 + 1，然后再循环，由此确定这个变量为循环变量，记为 `i`。接下来查看循环体，模拟之后发现等价为比较 `a[i] == 1 - 4a[i - 1]`，由此构造一串数字即可。构造字符串 `"1 -3 13 -51 205 -819"`，通过。

##### phase_3
大致浏览一下反汇编文件，发现有很多无条件转移与条件转移，考虑与 `if/else, switch` 有关。根据 `sscanf` 的压栈情况以及格式化语句，可以知道有三个局部变量，分别记为 `int a; int b; char c;`。首先尝试输入 `1 5 a 1`, 发现经历了一些列判断后，代码都会跳转到结构类似的比较语句或者跳转到 `explode_bomb`。考察比较语句，其逻辑为 
```c++
d = 'w'     // 或为其他字符
// 根据字母的排序得到提示 overflow，说明真结局可能与栈溢出攻击相关
if (b == 987)   // 或为其他值
{
    if (d == c)
    {
        clear();
    }
    else
    {
        explode_bomb();
    }
}
```
故只需要根据值来确定 `a, b, c`， `a, b, c` 相互不影响，挑选一条分支即可，如 `233 377 o`,检验后发现通过。
实际上考察所有输入值后，可以发现前两个数的排列为斐波那契数列。

##### phase_4
通过静态分析可以知道本题会把字符串作为 `long long` 读入，要求这个数的高 32 位和低 32 位都满足大于 0 小于等于 14。
接着，函数以这个数的高 32 位调用 `hope(int)`。如果返回值为 `0x1000000`则通过 `phase_4`
`hope(int)` 是一个递归调用函数，其大概流程是：
```c++
int hope(int n)
{
    if (n == 0)
    {
        return 1;
    }
    else
    {
        int y = hope (n >> 1);
        if ((n & 0x1) == 0)
        {
            return (y * y) << 2;
        }
        else
        {
            return y * y;
        }
    }
}

```
从功能上来说，这个函数执行的操作是：对 `n`，从低到高考察其二进制位，若为 0 ， `y = (y * y) << 2`, 否则 `y =(y * y)`。 `y` 初始为 `1`。
将我们需要得到的返回值 `0x1000000` 逆向分析，得到 `n = 0b1100`，由此可以得到密码，如 `0xC0000001`，即十进制下的 `51539607553`，尝试后通过。