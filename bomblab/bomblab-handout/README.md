##### phase_1
进入 `phase_1`，注意到函数 `string_not_equal`， 且传递参数之一为 `"Computer science is not a boring subject"`，检验通过。

##### phase_2
首先进入 `phase_2` 的反汇编代码，注意到有个函数 `read_six_numbers`。观察传参情况，发现传了我们输入的字符串以及一个（反汇编器提示的）数组，跟入 `read_six_numbers` 看一看。

注意到前面似乎一直在传递参数，且每一个参数都是 `eax` 加上一定的偏移量，由此可以推断这是一个 `int` 数组（其实也可能是 `unsigned`,不过后面可以排除）。

![2_1](pic/2_1.png)

结合 `sscanf` 以及后面的几行代码可以知道，`read_six_numbers` 的条件是读取到六个整数，且第一个整数不为 `0`。由此，这个函数已经结束，回到 `phase_2`

接下来执行的代码首先储存了数组的首地址，然后还设置了一个变量，当这个变量等于 5 时跳转。可以发现这里的跳转是正确出口，接下来考虑如何让这个变量等于 5。

再次查看代码，发现在一个 `cmp` 语句后出现了条件跳转，其中一个分支可以让这个变量 + 1，然后再循环，由此确定这个变量为循环变量，记为 `i`。接下来查看循环体，模拟之后发现等价为比较 `a[i] == 1 - 4a[i - 1]`，由此构造一串数字即可。构造字符串 `"1 -3 13 -51 205 -819"`，通过。

##### phase_3
大致浏览一下反汇编文件，发现有很多无条件转移与条件转移，考虑与 `if/else, switch` 有关。根据 `sscanf` 的压栈情况以及格式化语句，可以知道有三个局部变量，分别记为 `int a; int b; char c;`。首先尝试输入 `1 5 a 1`, 发现经历了一些列判断后，代码都会跳转到结构类似的比较语句或者跳转到 `explode_bomb`。考察比较语句，其逻辑为 
```c++
d = 'w'     // 或为其他字符
// 根据字母的排序得到提示 overflow，说明真结局可能与栈溢出攻击相关
if (b == 987)   // 或为其他值
{
    if (d == c)
    {
        clear();
    }
    else
    {
        explode_bomb();
    }
}
```
故只需要根据值来确定 `a, b, c`， `a, b, c` 相互不影响，挑选一条分支即可，如 `233 377 o`,检验后发现通过。
实际上考察所有输入值后，可以发现前两个数的排列为斐波那契数列。

##### phase_4
通过静态分析可以知道本题会把字符串作为 `long long` 读入，要求这个数的高 32 位和低 32 位都满足大于 0 小于等于 14。
接着，函数以这个数的高 32 位调用 `hope(int)`。如果返回值为 `0x1000000`则通过 `phase_4`
`hope(int)` 是一个递归调用函数，其大概流程是：
```c++
int hope(int n)
{
    if (n == 0)
    {
        return 1;
    }
    else
    {
        int y = hope (n >> 1);
        if ((n & 0x1) == 0)
        {
            return (y * y) << 2;
        }
        else
        {
            return y * y;
        }
    }
}

```
从功能上来说，这个函数执行的操作是：对 `n`，从低到高考察其二进制位，若为 0 ， `y = (y * y) << 2`, 否则 `y =(y * y)`。 `y` 初始为 `1`。
将我们需要得到的返回值 `0x1000000` 逆向分析，得到 `n = 0b1100`，由此可以得到密码，如 `0xC0000001`，即十进制下的 `51539607553`，尝试后通过。

##### phase_5
注意到通过在反汇编时选用 —C 选项可以反汇编出 C++ 风格的类及其方法。
本题考察虚函数的相关知识：对于一个含有虚函数的类，首地址将会是一个虚函数表，类通过这个虚函数表来调用虚函数。通过分析，可以首先得出三个有效字符串分别是：`杀杀杀！`、`退退退。`、`冲冲冲~`，在这之后根据字符串调用构造函数 `worldline*::worldline*`。接下来主程序通过虚函数表调用方法 `worldline*::dmail(int)`。跟进不同的 `dmail(int)` 中，发现对于三条世界线分别需要将 dmail 发送到 `2018`、`2021`或者 `2023` 年。最后主函数调用 `worldline::is_phase5_passable`,实测发现只有当为世界线 3 的时候才为真，故得到最终答案 `冲冲冲~ 2023`。

##### phase_6
主程序中调用了 `read_six_numbers`，并且根据后面的判断可以发现这六个数字需要在 `[0, 6]` 范围内。且如果 `build_target` 函数返回 `1` 则可以通过。

进入 `build_target` 函数，传入参数为 `arr[i]`。 注意到对 `arr[i]` 有一个大循环，最后是通过一个 `check_answer`来确定是否通过，参数是 `$rbp - 0x90`， 推测为结果数组，要求这个数组满足递增性。

回到主循环，可以发现首先调用了 `build_queue()`，跟进去查看，发现这个函数只是返回了一个节点。查看这个节点，可以发现这是一个循环列表。接着查看，在经历一些神秘的运算之后，进入到一个 `get_val` 的循环。可以写出 `get_val` 的C风格代码：
```c
int get_val(Node **pptr)
{
    Node *ptr = *pptr;
    int a = ptr->value;
    *pptr = ptr->link;
    return a;
}
```
可以理解为获取当前指针的值，并将指针向前移动一位。这个操作会执行 `arr[i]` 次，所获得的结果会被存到一个局部数组 `localArr[]`中。接下来这个 `localArr[arr[i]]` 被存入了 `res[i]`。之后便进入了一个 `put_val` 的循环。`put_val` 的参数调用 `get_val` 之前指针的位置。可以写出C风格代码：
```c
void put_val(Node **pptr, int val)
{
    Node *ptr = *pptr;
    ptr->value = val;
    *pptr = ptr->link;
}
```
也就是将元素存进当前的指针位置并将指针后移一位。注意这里的存储顺序是从 `localArr[arr[i]]` 到 `localArr[0]` 倒序存储。 随后进行下一次最外层循环。

在这里就可以确定函数的操作：对于一个循环链表，给定一个数字 `i`。获取当前位置之后第 `i` 个节点的值，并将走过的节点的值逆序存储。

通过查看节点得到链表为 `20 -> 60 -> 40 -> 50 -> 10 -> 30 `，构造字符串

`5 6 6 4 4 6`，成功。

##### secret_phase
由 `phase_3` 知需要利用栈溢出攻击，观察 `main.cpp` 中的 `read_line()` ，可以发现这个函数会对 `a[0] ~ a[40]` 进行写入，而主程序中的 `buffer[40]`，有可能发生溢出。查看汇编代码，发现刚好能够发生栈溢出。在 `password.txt` 的某一行之后添加空格即可。

注意到反汇编代码有一段类似于混淆的操作，静态分析失效，利用动态分析。
```asm
  401dc5:	eb ff                	jmp    401dc6 <secret_phase+0x11>       # 跳转的地址并非下一条指令
  401dc7:	c0 48 8d 3d          	ror    BYTE PTR [rax-0x73],0x3d         # 利用 jmp 来打乱代码顺序局部性
  401dcb:	45 15 00 00 e8 2c    	rex.RB adc eax,0x2ce80000
  401dd1:	f4                   	hlt    
  401dd2:	ff                   	(bad)  
  401dd3:	ff c7                	inc    edi
  401dd5:	45 fc                	rex.RB cld 
  401dd7:	de c0                	faddp  st(0),st
  401dd9:	ad                   	lods   eax,DWORD PTR ds:[rsi]
  401dda:	de 48 8d             	fimul  WORD PTR [rax-0x73]
```

进入 `secret_phase`，跟随执行，可以发现 `sscanf` 的格式化字符串为 `%ud`，输入测试数据 `114514` 进行测试。发现接下来的操作是比较 `in ^ 0xdeadc0de` 与 `0xbaadf00d`，需要相等才能够通过。根据异或的性质，进行运算 `0xbaadf00d ^ 0xdeadc0de = 1677734099`。
 
